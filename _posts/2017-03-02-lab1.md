---
layout:  post
title:   Lab 1
tagline: Automaton accepter
---

# Description

We will build an automaton for accepting words which:

- start with either `a` or `bb`
- followed by `c`
- followed by some `a`s (zero or more)
- end with either `b` or `c`

Examples: `acaaab` and `bbcb` are accepted. `acaa` (non-accepting state) and `bab`(junk state) are not.

# DFA

The automaton's diagram can look like:

![DFA](assets/dfa.svg)

A more compact form of describing it would be $(a\|bb)ca^n(b\|c), \ n \ge 0$

## Formal Description

A DFA $A$ is a 5-tuple


$$
A = (Q, \Sigma, \delta, q_0, F)
$$


Where:

- $Q$ is the set of states. In our case, $Q = \lbrace q_0, q_1, q_2, q_3, q_4, q_5 \rbrace$

- $q0 \in Q$ is the starting state

- $F \subset Q$ is the set of final/accepting states. In our case, $F = \lbrace q_4, q_5 \rbrace$

- $\Sigma$ is the alphabet, a set of symbols. In our case, $\Sigma = \lbrace a, b, c \rbrace$

- $\delta:Q \times \Sigma \rightarrow Q$ is the transition function. $\delta(q, x)=q'$ tells us that when we are in state $q$ and we read the symbol $x$, we move in state $q'$. In our case:


$$
\begin{align}
\delta(q_0, a) &= q_2 \\

\delta(q_0, b) &= q_1 \\

\delta(q_1, b) &= q_2 \\

...
\end{align}
$$

It's useful to see it as a table, where the first column is the current state and the first column is the symbol we read:

| $\delta$   | **a** | **b** | **c** |
| ---------- | :---: | :---: | :---: |
| $\bf{q_0}$ | $q_2$ | $q_1$ |       |
| $\bf{q_1}$ |       | $q_2$ |       |
| $\bf{q_2}$ |       |       | $q_3$ |
| $\bf{q_3}$ | $q_3$ | $q_4$ | $q_5$ |
| $\bf{q_4}$ |       |       |       |
| $\bf{q_5}$ |       |       |       |

Some cells are left **blank**, for example $(q_0, c)$. That is because we have no transition from $q_0$ to $c$. Any missing transition can be thought as going into a *junk state*. It is not accepting and has no out-bound transitions so we immediately reject.



## Implementation

You probably want to keep in memory at least the `accepting states` and the `transition` matrix.

You should implement two functions:

- `build_DFA()` which fills the `transition` matrix. Don't forget about the `junk` state.
- `evaluate(word)` which returns `true` if the automaton accepts it, and `false` otherwise.
  - start in state `0`,
  - go through each `symbol` in  `word` moving among the automaton's `states` accordingly
  - check if the `state` you stopped in is `accepting`


## Project

Make a program to:

- read the DFA definition from a file (say `DFA.in`)
- read the input word from the keyboard (say `"acaaab"`)
- print to the console whether it is accepted or not

`DFA.in` for the automaton above:

```
4 5
0 a 2
0 b 1
1 b 2
2 c 3
3 a 3
3 b 4
3 c 5
```

The first line lists the `accepting states`. In our case, `4` and `5` .

Each subsequent line corresponds to one cell in the `transition` matrix. Eg: `0 a 2` for $\delta(q_0, a)=q_2$.

## Another Example

DFA accepting an even number of `a`s:

$$
a^{2n}, n\ge0
$$

Examples: `aa`, `aaaa`, `λ` (the empty word) are accepted. `a`, `aaa` are rejected.

![DFA_even](assets/dfa_even.svg)


Matrix:

| $\delta$   | **a** |
| ---------- | :---: |
| $\bf{q_0}$ | $q_1$ |
| $\bf{q_1}$ | $q_0$ |


`DFA.in`:

```
0
0 a 1
1 a 0
```



# NFA

The first automaton becomes non-deterministic if we add the transition $\delta(q_1, b)=q_5$ (`1 b 5` in `DFA.in`). That means we can go from `q1` with `b` in either `q3` **or** `q5`.

This makes the automaton accept the word `bb`.

## Implementation

- A cell in the transition matrix $\delta$ will not be a single state $q2$, it will be a *set* of states $\{ q_3, q_5 \}$.
- The `current_state` will no longer be a single state, it will be a *set* of states. When consuming a symbol `x`, move *each* of the current state $q$ to where $\delta(q, x)$ points (it is a list as well).



# λ-NFA

The first automaton becomes a λ-NFA if we add the transition $\delta(q_2, \lambda)=q_4$  (`2 _ 4` in `DFA.in`). That means we can go from `q2` with `λ` (consuming no additional symbol from the word) in `q4`.

This makes the automaton accept the word `a` ($q_0 \rightarrow q_2 \rightarrow q_4$).

## Implementation

- The transition matrix $\delta$ can be extended with an additional column $\lambda$.
- When consuming a symbol `x`, from the current state $q$, also consider states $s$  reachable by $\lambda$ ($\delta(q, \lambda) = s$)
- Treat situation when $\delta(q, \lambda)=s$ and $\delta(s, \lambda)=r$. That means $r$ is **also** λ-reachable from $q$.